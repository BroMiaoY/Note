# 软工/测试相关



## 软件开发生命周期

### 6个阶段

#### 1 问题定义以及规划阶段

软件开发目的及其可行性，制定开发计划

#### 2 需求分析阶段

过程的利益相关者讨论对最终产品的要求，确保所有流程参与者都清楚的了解每个需求如何实施的

#### 3 软件设计阶段

设计架构

#### 4 软件编码阶段

编码

#### 5 软件测试阶段

检测代码缺陷

#### 6 软件运行维护阶段

版本、产品上线，以及缺陷的修复



### 软件开发模型

#### 1 瀑布模型

一步一步的进行，每一个阶段完成后才进入下一个阶段，且只执行一次

只适合**需求明确**，**变更小**的中小型项目，不适合长期

#### 2 迭代模型

一次完整的经过所有工作流程，类似小型的**瀑布模型**

每次迭代均产生一个**可发布的产品**

该产品为最终产品的一个**子集**

#### 3 螺旋模型

适用于需求不明确的情况，便于风险控制和需求变更

沿螺旋线进行**若干次迭代**（制定计划、风险分析、实施工程、客户评估）

风险识别、分析、控制，消耗的人力、资源很大

#### 4 V模型

注重**测试和验证**的过程，并集成到了开发周期的每个阶段中

#### 5 W模型

V模型的改良，**测试活动**与**软件开发**同时进行

#### 6 敏捷模型

大的项目分为多个相互联系，但也可以独立运行的小项目，此过程中软件一直**可使用**状态



# 数据库

## 1 SQL

### 1.1 分页

#### 1.1.1 MySQL的分页语法

**limit**子句可实现分页查找

例：

```sql
select prod_name from products limit 5;
```

**一个值**的LIMIT总是从**第一行开始**，给出的数为返回的行数

**两个值**的LIMIT可以**指定行号**为第一个值的位置开始

***

#### 1.1.2 优化Limit分页

[首先了解数据库索引原理](#数据库索引原理)

当**offset偏移量太大**时：

```sql
select * from tb_a limit 100000, 100;
```

这里的前100000行数据都浪费了，这时需要进行分页优化

- 使用索引查询：

  这里的索引必须是主键，因为主键索引是**聚簇索引**

  如果使用二级索引需要**回表**，也就是到数据库数据结构中从叶子节点中到非叶子节点找到主键索引

  ```sql
  --使用二级索引
  select * from tb_a where number=1 limit 100000, 100;
  
  --使得查询的数据在索引上
  select id from tb_a where number=1 limit 100000, 100;
  ```

  

- 子查询优化：

  ```sql
  select * from table_a
  where number = 1 id >=(
      select id from tb_a 
      where number=1
      limit 100000, 1
  )limit 100;
  ```

- 如果可以记录上一次的取数位置，那么下一次可以从上一次的位置开始扫描，即可避免offset的偏移，可以利用前后端的交互进行传递



### 1.2 数据库索引用的什么数据结构？

B+树

#### 1.2.1 B+树的特点，为什么用这个数据结？

在**大规模**数据存储中，实现索引查询

树节点的存储元素是有限的，如果**元素数量非常多**的话，查找就退化成了节点内部的**线性查找**

导致二叉树结构由于树的深度过大导致**磁盘I/O读写**过于频繁，查询效率低下

B+树非叶子节点不存储数据，而B树存储，相同大小数据块，能存耕读的B+树索引



### 1.3 数据库sql跨表查询

- 子查询

  嵌套在其他sql查询的**where子句**中

  eg:

  ```sql
  select * from student id in (
  	select student_id 
  	from student
      where student_name = 'Tom'
  )
  ```

- 内连接

  通过关键字inner join连接两张表，只返回满足on条件的，两张表的**交集**数据

  eg:（inner join 可以省略 inner 直接写成join）

  ```sql
  select *
  from a join b
  on a.in = b.id;
  
  select *
  from student as s
  join teacher as t
  on s.Tid =t.Tid;
  ```

- 外连接：

  eg:

  ```
    a表     id       name         b表     id   job   parent_id   
     		  1        张三             	   1     23       1   
   	      2        李四          		   2     34       2   
    		  3        王武          		   3     34       4       
  ```

  - 左外链接

    left join 关键字从左表返回所有行，右表中没有的则悬浮，填NULL

    ```sql
    select a.*,b.*
    from a left join b
    on a.id = b.parent_id
    ```

    ```
      1   张三                  1     23     1   
      2   李四                  2     34     2   
      3   王武                  null   
    ```

  - 右外连接

    right join 关键字从右表返回所有行，左表中没有的则悬浮，填NULL

    ```sql
    select a.*,b.*
    from a right join b
    on a.id = b.parent_id
    ```

    ```
     1   张三                  1     23     1   
     2   李四                  2     34     2   
     null                     3     34     4   
    ```

- 全连接（MySQL 不支持）

  ```sql
  select a.*,b.*
  from a full join b 
  on a.id = b.parent_id
  ```

  ```
   1   张三                 1     23     1   
   2   李四                 2     34     2   
   null               　　  3     34     4   
   3   王武                 null
  ```

- 交叉连接（笛卡尔积）

  返回，两个数据表的乘积

  ```sql
  select * from a,b;
  ```

  ```
    a表     id       name         b表     id   job   parent_id   
     		  1        张三             	   1     23       1
            1        张三             	   2     34       2
            1        张三             	   3     34       4
   	      2        李四          		   1     23       1
   	      2        李四          		   2     34       2
            2        李四          		   3     34       4
    		  3        王武          		   1     23       1 
            3        王武          		   2     34       2 
            3        王武          		   3     34       4 
  ```

---

### 1.4 InnoDB和MyIsam有什么区别

> 问：MySQL有哪些存储引擎？
>
> 答：InnoDB, Myisam, Memory等

###### 主键：

- InnoDB必须有唯一主键，当用户没有定义主键时，数据库会自定义一个隐藏的列作为主键
- 而MyIsam不一定有主键

###### 外键：

- 如果把一个含有外键的表，存储引擎转化为MyIsam的话，会报错

###### 聚簇索引：

- 聚簇索引：数据文件和索引文件是在一起的

  ![image-20230717151218902](D:\miao\note\八股文\八股文\image-20230717151218902.png)

- 非聚簇索引：数据文件和索引文件是分开的，索引文件给出数据文件的**地址**

  ![image-20230717151247458](D:\miao\note\八股文\八股文\image-20230717151247458.png)

###### 行数：

由于InnoDB支持**事务**，在同一时刻下不同事务的行数是不同的，所以不存储行数

###### 行锁：

InnoDB默认行锁

MyIsam默认表锁

|              |               InnoDB               |                      MyIsam                       |
| :----------: | :--------------------------------: | :-----------------------------------------------: |
|   **事务**   |                支持                |                      不支持                       |
|   **主键**   |              一定要有              |                      不一定                       |
|   **外键**   |                支持                |                      不支持                       |
| **聚簇索引** |                 是                 |                       不是                        |
| **全文索引** |     不支持（V5.7后也开始支持）     |                       支持                        |
|   **行数**   |               不存储               |                       存储                        |
|   **行锁**   |                支持                |                      不支持                       |
| **存储文件** | frm（表定义文件）、ibd（数据文件） | frm（表定义文件）、myd（数据文件）、myi(索引文件) |

---

#### 应用场景

- 如果大部分的操作是**查询**：MyIsam。比如BI报表（离线数据库）
- 如果需要事务：InnoDB
- 如果是普通的业务系统，涉及到CRUD的操作：InnoDB

---

### 1.5 SQL中的聚合函数

cout()

avg()

sum()

max()

min()

---

### 1.6  SQL中怎么将行转成列

如下将下表转换成：

![image-20230717175750986](D:\miao\note\八股文\八股文\image-20230717175750986.png)

![image-20230717175758521](D:\miao\note\八股文\八股文\image-20230717175758521.png)

- 使用case ... when ... then语句实现行转列

  ```sql
  select userid, 
  sum(case 'subject' when '语文' then score else 0 end) as '语文'，
  sum(case 'subject' when '数学' then score else 0 end) as '数学',
  sum(case 'subject' when '英语' then score else 0 end) as '英语',
  sum(case 'subject' when '政治' then score else 0 end) as '政治'
  from tb_score group by userid
  ```

  使用sum()函数是为了更够使用group by根据userid进行分组 

- if()函数实现

  ```sql
  select userid,
  sum(if('subject' = '语文', score, 0)) as '语文',
  sum(if('subject' = '数学', score, 0)) as '数学',
  sum(if('subject' = '英语', score, 0)) as '英语',
  sum(if('subject' = '政治', score, 0)) as '政治'
  from tb_score group by userid
  ```

---

### 1.7 SQL注入

###### SQL注入的原理：

将SQL代码伪装到输入参数中，传递到数据服务器解析并执行的一种攻击手法

对server端参数中植入一些SQL代码，sever端在执行SQL操作时，会拼接对应的参数，导致一些预期之外的操作

eg:

```sql
SELECT * FROM user WHERE username = 'ls' AND password = '123456'

# ' or 1=1 # 作为用户名参数
select * from user where username='' or 1=1 #' and password='123456'
```

#会忽略后面的语句，而1=1是衡真的，因此这个SQL将查询出所有的登录用户

---

###### 解决SQL注入：

1. 严格的参数校验

2. SQL预编译

   MySQL具有[预编译](#预编译)的功能



# 计网



# 操作系统



# 数据结构与算法



# C语言



# JAVA



# 补充知识

### <span id="数据库索引原理">数据库索引原理</span>

#### 1 二叉树$\rightarrow$平衡二叉树$\rightarrow$B-树$\rightarrow$B+树

- 二叉树

  > + 每个节点最多两个子树
  >
  > + 左子树值小于父节点，右子树值大于父节点

  若将升序的数组插入树中，树会变成：

  ![image-20230717100348417](D:\miao\note\八股文\八股文\image-20230717100348417.png)

  这棵树退化成一个**线性链表**，查询效率更低

  因此为了保持平衡，出现了**平衡二叉树**

- 平衡二叉树

  > + 满足二叉树的特性
  >
  > + 左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一颗平衡二叉树
  > + 查找效率和**二分查找**相同

  树的高度为$h$，那么每层最多容纳的节点数量为$2^{(n-1)}$，整棵树最多容纳节点$2^0+2^1+2^3+...+2^{(h-1)}$

- B-树

  一颗m阶的B-Tree的特征：

  > + 每个结点最多有m个子节点
  > + 除了根节点和叶子节点外，每个节点最少有$\frac{m}{2}$（向上取整）个子节点
  > + 如果根节点不是叶子节点，那根节点至少包含两个子节点
  > + 所有叶子节点都位于同一层
  > + 每个节点都包含K个元素，$\frac{m}{2}\leq k < m$（这里$\frac{m}{2}$向下取整）
  > + $左节点值 \leq 元素值 \leq 右节点值$

  B-Tree的查询效率不比平衡二叉树

  但查询经过的**节点数少**得多，因此查询一条数据需要**更少次数的磁盘I/O**

  ---

  **数据库中B-Tree的数据结构：**

  普通B-Tree的节点中，元素是一个数字

  > 但数据库中B-Tree，元素部分分成了key-data的形式
  >
  > key是数据的主键，data是具体的数据
  >
  > 找一条数的时候，就沿着根结点往下找就ok了，效率是比较高的

  ![image-20230717103615880](D:\miao\note\八股文\八股文\image-20230717103615880.png)

- B+树

  B+树是在B-Tree上的一种优化，使其更适合实现外存储索引结构

  > + 所有**非叶子节点**只存储**关键字信息**
  >
  > + 所有**数据**都存在叶子节点中
  >
  > + 所有叶子节点中包含了**全部元素信息**
  >
  > + 所有叶子节点之间都有一个**链指针**

​		![image-20230717104942142](D:\miao\note\八股文\八股文\image-20230717104942142.png)

---

#### 2 B-Tree or B+Tree

> 1.B-Tree非叶子节点也可以保存具体数据，因此查找到某个关键字时就可以返回；而B+Tree所有的数据都在叶子节点，每次查找都要找叶子节点。因此相同高度的B-Tree和B+Tree，**B-Tree的查找效率跟高**

> 2.B+Tree的所有数据都在叶子节点，且结点之间有指针连接，在找大于或小于某个关键字时。B+Tree只需要**沿着链表遍历**即可。而B-Tree则需要遍历该**关键字结点的根结点**去搜索。

> 3.由于B-Tree的每个结点（一个结点可以理解为一个数据页）都存储主键+实际数据，B+Tree的非叶子结点只存储关键字信息，而每个页大小有限，所以**同一页能存储的B-Tree比B+Tree存储的更少**。因此在相同总量的数据下，**B-Tree的深度比B+Tree的深度大**，查询时的**磁盘I/O次数更多**，影响查询效率。

---



### <span id='预编译'>预编译</span>

