# 软工/测试相关



## 软件开发生命周期

### 6个阶段

#### 1 问题定义以及规划阶段

软件开发目的及其可行性，制定开发计划

#### 2 需求分析阶段

过程的利益相关者讨论对最终产品的要求，确保所有流程参与者都清楚的了解每个需求如何实施的

#### 3 软件设计阶段

设计架构

#### 4 软件编码阶段

编码

#### 5 软件测试阶段

检测代码缺陷

#### 6 软件运行维护阶段

版本、产品上线，以及缺陷的修复



### 软件开发模型

#### 1 瀑布模型

一步一步的进行，每一个阶段完成后才进入下一个阶段，且只执行一次

只适合**需求明确**，**变更小**的中小型项目，不适合长期

#### 2 迭代模型

一次完整的经过所有工作流程，类似小型的**瀑布模型**

每次迭代均产生一个**可发布的产品**

该产品为最终产品的一个**子集**

#### 3 螺旋模型

适用于需求不明确的情况，便于风险控制和需求变更

沿螺旋线进行**若干次迭代**（制定计划、风险分析、实施工程、客户评估）

风险识别、分析、控制，消耗的人力、资源很大

#### 4 V模型

注重**测试和验证**的过程，并集成到了开发周期的每个阶段中

#### 5 W模型

V模型的改良，**测试活动**与**软件开发**同时进行

#### 6 敏捷模型

大的项目分为多个相互联系，但也可以独立运行的小项目，此过程中软件一直**可使用**状态



# 数据库

## 1 SQL

### 1.1 分页

#### 1.1.1 MySQL的分页语法

**limit**子句可实现分页查找

例：

```sql
select prod_name from products limit 5;
```

**一个值**的LIMIT总是从**第一行开始**，给出的数为返回的行数

**两个值**的LIMIT可以**指定行号**为第一个值的位置开始

#### 1.1.2 优化Limit分页

[首先了解数据库索引原理](#数据库索引原理)

当**offset偏移量太大**时：

```sql
select * from tb_a limit 100000, 100;
```

这里的前100000行数据都浪费了，这时需要进行分页优化

- 使用索引查询：

  这里的索引必须是主键，因为主键索引是**聚簇索引**

  如果使用二级索引需要**回表**，也就是到数据库数据结构中从叶子节点中到非叶子节点找到主键索引

  ```sql
  --使用二级索引
  select * from tb_a where number=1 limit 100000, 100;
  
  --使得查询的数据在索引上
  select id from tb_a where number=1 limit 100000, 100;
  ```

- 子查询优化：

  ```sql
  select * from table_a
  where number = 1 id >=(
      select id from tb_a 
      where number=1
      limit 100000, 1
  )limit 100;
  ```

- 如果可以记录上一次的取数位置，那么下一次可以从上一次的位置开始扫描，即可避免offset的偏移，可以利用前后端的交互进行传递

---



### 1.2 数据库索引用的什么数据结构？

B+树

#### 1.2.1 B+树的特点，为什么用这个数据结？

在**大规模**数据存储中，实现索引查询

树节点的存储元素是有限的，如果**元素数量非常多**的话，查找就退化成了节点内部的**线性查找**

导致二叉树结构由于树的深度过大导致**磁盘I/O读写**过于频繁，查询效率低下

B+树非叶子节点不存储数据，而B树存储，相同大小数据块，能存耕读的B+树索引

---



### 1.3 数据库sql跨表查询

- 子查询

  嵌套在其他sql查询的**where子句**中

  eg:

  ```sql
  select * from student id in (
  	select student_id 
  	from student
      where student_name = 'Tom'
  )
  ```

- 内连接

  通过关键字inner join连接两张表，只返回满足on条件的，两张表的**交集**数据

  eg:（inner join 可以省略 inner 直接写成join）

  ```sql
  select *
  from a join b
  on a.in = b.id;
  
  select *
  from student as s
  join teacher as t
  on s.Tid =t.Tid;
  ```

- 外连接：

  eg:

  ```
    a表     id       name         b表     id   job   parent_id   
     		  1        张三             	   1     23       1   
   	      2        李四          		   2     34       2   
    		  3        王武          		   3     34       4       
  ```

  - 左外链接

    left join 关键字从左表返回所有行，右表中没有的则悬浮，填NULL

    ```sql
    select a.*,b.*
    from a left join b
    on a.id = b.parent_id
    ```

    ```
      1   张三                  1     23     1   
      2   李四                  2     34     2   
      3   王武                  null   
    ```

  - 右外连接

    right join 关键字从右表返回所有行，左表中没有的则悬浮，填NULL

    ```sql
    select a.*,b.*
    from a right join b
    on a.id = b.parent_id
    ```

    ```
     1   张三                  1     23     1   
     2   李四                  2     34     2   
     null                     3     34     4   
    ```

- 全连接（MySQL 不支持）

  ```sql
  select a.*,b.*
  from a full join b 
  on a.id = b.parent_id
  ```

  ```
   1   张三                 1     23     1   
   2   李四                 2     34     2   
   null               　　  3     34     4   
   3   王武                 null
  ```

- 交叉连接（笛卡尔积）

  返回，两个数据表的乘积

  ```sql
  select * from a,b;
  ```

  ```
    a表     id       name         b表     id   job   parent_id   
     		  1        张三             	   1     23       1
            1        张三             	   2     34       2
            1        张三             	   3     34       4
   	      2        李四          		   1     23       1
   	      2        李四          		   2     34       2
            2        李四          		   3     34       4
    		  3        王武          		   1     23       1 
            3        王武          		   2     34       2 
            3        王武          		   3     34       4 
  ```

---



### 1.4 InnoDB和MyIsam有什么区别

> 问：MySQL有哪些存储引擎？
>
> 答：InnoDB, Myisam, Memory等

###### 主键：

- InnoDB必须有唯一主键，当用户没有定义主键时，数据库会自定义一个隐藏的列作为主键
- 而MyIsam不一定有主键

###### 外键：

- 如果把一个含有外键的表，存储引擎转化为MyIsam的话，会报错

###### 聚簇索引：

- 聚簇索引：数据文件和索引文件是在一起的

  ![image-20230717151218902](D:\miao\note\八股文\八股文\image-20230717151218902.png)

- 非聚簇索引：数据文件和索引文件是分开的，索引文件给出数据文件的**地址**

  ![image-20230717151247458](D:\miao\note\八股文\八股文\image-20230717151247458.png)

###### 行数：

由于InnoDB支持**事务**，在同一时刻下不同事务的行数是不同的，所以不存储行数

###### 行锁：

InnoDB默认行锁

MyIsam默认表锁

|              |               InnoDB               |                      MyIsam                       |
| :----------: | :--------------------------------: | :-----------------------------------------------: |
|   **事务**   |                支持                |                      不支持                       |
|   **主键**   |              一定要有              |                      不一定                       |
|   **外键**   |                支持                |                      不支持                       |
| **聚簇索引** |                 是                 |                       不是                        |
| **全文索引** |     不支持（V5.7后也开始支持）     |                       支持                        |
|   **行数**   |               不存储               |                       存储                        |
|   **行锁**   |                支持                |                      不支持                       |
| **存储文件** | frm（表定义文件）、ibd（数据文件） | frm（表定义文件）、myd（数据文件）、myi(索引文件) |

#### 应用场景

- 如果大部分的操作是**查询**：MyIsam。比如BI报表（离线数据库）
- 如果需要事务：InnoDB
- 如果是普通的业务系统，涉及到CRUD的操作：InnoDB

---



### 1.5 SQL中的聚合函数

cout()

avg()

sum()

max()

min()

---



### 1.6  SQL中怎么将行转成列

如下将下表转换成：

![image-20230717175750986](D:\miao\note\八股文\八股文\image-20230717175750986.png)

![image-20230717175758521](D:\miao\note\八股文\八股文\image-20230717175758521.png)

- 使用case ... when ... then语句实现行转列

  ```sql
  select userid, 
  sum(case 'subject' when '语文' then score else 0 end) as '语文'，
  sum(case 'subject' when '数学' then score else 0 end) as '数学',
  sum(case 'subject' when '英语' then score else 0 end) as '英语',
  sum(case 'subject' when '政治' then score else 0 end) as '政治'
  from tb_score group by userid
  ```

  使用sum()函数是为了更够使用group by根据userid进行分组 

- if()函数实现

  ```sql
  select userid,
  sum(if('subject' = '语文', score, 0)) as '语文',
  sum(if('subject' = '数学', score, 0)) as '数学',
  sum(if('subject' = '英语', score, 0)) as '英语',
  sum(if('subject' = '政治', score, 0)) as '政治'
  from tb_score group by userid
  ```

---



### 1.7 SQL注入

###### SQL注入的原理：

将SQL代码伪装到输入参数中，传递到数据服务器解析并执行的一种攻击手法

对server端参数中植入一些SQL代码，sever端在执行SQL操作时，会拼接对应的参数，导致一些预期之外的操作

eg:

```sql
SELECT * FROM user WHERE username = 'ls' AND password = '123456'

# ' or 1=1 # 作为用户名参数
select * from user where username='' or 1=1 #' and password='123456'
```

#会忽略后面的语句，而1=1是衡真的，因此这个SQL将查询出所有的登录用户

###### 解决SQL注入：

1. 严格的参数校验

2. SQL预编译

   MySQL具有[预编译](#预编译)的功能

---



### 1.8 一张表部分数据更新到另一张表

采用**关联更新**的方法

```sql
update b set b.col=a.col from a, b where a.id=b.id;
update b set b.col=a.col from b join a on a.id=b.id;
update b set b.col=a.col from b left join a on a.id=b.id
```

---



### 1.9 where和having的区别

where是**约束声明**，约束来自数据库的数据，再**结果返回之前**起作用，where中**不能使用聚合函数**

having是过滤声明，在查询返回集中**对查询结果进行过滤操作**，在having中**可以使用聚合函数**

**where性能比having好**，where在查询中就过滤了不需要的数据



# 计网

### 1.1 七层网络体系结构

#### 1.为什么七层

支持异构网络的互联互通

#### 2.七层分别负责的内容（功能）

|                |                             任务                             |                             功能                             |             传输单位             |      硬件      |                协议                |
| :------------: | :----------------------------------------------------------: | :----------------------------------------------------------: | :------------------------------: | :------------: | :--------------------------------: |
|   **物理层**   |                       透明的传输比特流                       |             为**数据段设备**提供传送**数据通路**             |               比特               | 集线器、中继器 |                                    |
| **数据链路层** |          将网络层传输下来的**IP数据报**组装成**帧**          | a.**链路连接**的建立、拆除和分离<br />b.帧定界和帧同步<br />c.差错检测 |                帧                |  交换机、网桥  |     PPP、HDLC、SDLC、STP、ARQ      |
|   **网络层**   | a.将传输层下来的报**文段**封装成组<br />b.**选择合适的路由**，使得传输层下来的分组能够交付到目的主机 | a.为传输层提供服务<br />b.组包和拆包<br />c.路由选择<br />d.拥塞控制 |              数据段              |     路由器     |  ICMP、ARP、RARP、IP、IGMP、OSPF   |
|   **传输层**   |               负责**主机中两个**进程之间的通信               | a.为端到端连接提供**可靠的服务**<br />b.为端到端连接提供流量控制、差错控制、服务质量等管理服务 | 报文段（TCP）或用户数据报（UDP） |                |              TCP、UDP              |
|   **会话层**   |                 **不同主机上**各进程间的对话                 | **管理主机间的会话进程**，包括建立、管理以及终止进程间的会话。是一种端到端的服务 |                                  |                |                                    |
|   **表示层**   | 负责处理在两个内部**数据表示结构不同**的通信系统之间交换**信息的格式** | 为数据**加密和解密**以及为提高数据**传输效率**提供必须的**数据压缩以及解压**等功能 |                                  |                |                                    |
|   **应用层**   |                      提供系统与用户接口                      |       a.文件传输<br />b.访问和管理<br />c.电子邮件服务       |                                  |                | FTP、SMTP、POP3、HTTP、DNS、TELnet |

---



### 1.2 五层网络体系结构


|                |                                                              |
| -------------- | ------------------------------------------------------------ |
| **应用层**     | （1）应用层：直接为用户的应用进程提供服务<br />（2）因特网中的应用层协议很多，万维网支持的**HTTP**、电子邮件支持的SMTP、支持文件传输的**FTP** |
| **运输层**     | （1）传输层：负责向**主机中两个进程间**的通讯提供服务。由于一个主机可同时运行多个进程，因此运输层有**复用**和**分用**的功能<br />a.复用，**多个应用层进程**可以同时使用下面**运输层的服务**<br />b.分用，把搜集的信息分别交给上面**应用层中对应的进程**<br />（2）运输层主要使用的协议：<br />Ⅰ.传输控制协议TCP：**面向连接**的，数据传输的单位是**报文段**，能够提供**可靠的交付**。<br />Ⅱ.用户数据报协议UDP：无连接的，数据传输的单位是**用户数据报**，不保证提供可靠交付，只提供“尽最大努力交付” |
| **网络层**     | （1）负责**分组交换网**上**不同主机**提供通信服务。在发送数据时，网络把运输层残生的报文段或用户数据报**封装成分组或包**进行传送。在TCP/IP体系中，由于网络层使用IP协议，因此分组也叫做**IP数据报**，或简称数据报<br />（2）**选中合适的路由**，使原主机运输层所传下来的分组，能够通过网络中的路由器找到目的主机 |
| **数据链路层** | 将网络层下来的IP数据报封装成帧，在两个相邻结点之间的链路上“透明”地传送帧中地数据。每一帧包括数据和必要地控制信息（如：同步信息、地址信息、差错控制等）。典型地帧长是几百到一千多字节 |
| **物理层**     | 传输的数据单位是**比特**。物理层的任务是透明的传送比特流     |

---



### 1.3 网络编程协议？客户端发送给服务器的请求，怎么确定具体的协议？

> 客户端发送给服务器的请求，根据**统一资源定位系统（URL）**来确定具体的协议

##### 解析：

完整的URL包括：**协议-网址-文件地址**。

协议部分以`//`为分隔符，在因特网中，可以使用的多种协议：

- HTTP——超文本传输协议
- FTP——文件传输协议
- Gopher——网际Gopher协议
- FIle——本地文件传输协议
- HTTPS——**安全套接字层**超文本传输协议（http的安全版）

---



### 1.4 TCP、HTTP、FTP分别属于那一层？

> TCP：传输层；HTTP、FTP：应用层

##### 解析：

###### 1.TCP协议简介

（1）TCP协议的特性

TCP协议是面向连接的，提供**全双工**的服务，数据流可以**双向传输**。也是**点对点**的，即在单个发送方和单个接收方之间的连接。

（2）TCP报文段结构

- **序号**：TCP序号是**数据流中的字节数**，不是分组序号。表示该报文数据字段**首字节的序号**

- **确认号**：TCP使用累计确认，确认号是第一个**未收到的字节序号**，表示希望接受到的下一个字节

- **首部长度**：通常选项字段为空，所以一般TCP受不得长度是**20字节**

- **选项字段**（可选与变长）：用于发送方与接收方协商MSS（最大报文长度），或在高速网络环境下用作窗口调节因子

- **标志字段**：

  - **AKC**：指示确认字段中的值是有效的
  - **RST，SYN，FIN**：连接建立与拆除
  - **PSH**：指示接收方应立即将数据交给上层
  - **URG**：报文段中存在着（被发送方的上层实体置位）“紧急”的数据

- **接收窗口**：用于流量控制（表示接收方还有多少可用的缓存空间）

   TCP RFC 并没有规定失序到达的分组应该如何处理，而是交给程序员。可以选择丢弃或保留。如果发生超时，TCP **只重传第一个已发送而未确认的分组**，超时时间间隔会设置为原来的 2 倍。

（3）流量控制

如果应用程序读取数据相当慢，而发送方发送数据太多、太快，会很容易使接收方的接收缓存溢出，流量控制就是用来进行发送速度和接收速度的匹配。发送方维护一个“接收窗口”变量，这个变量表示接收方当前可用的缓存空间。



# 操作系统

### 1.1 Linux里如何查看一个想要知道的进程

查看进程运行状态的指令：

```shell
ps -aux | grep PID
```

###### 解析：

> //ps使用示例
>
> //显示当前所有进程 `ps -A`
>
> //与grep联用查找某进程 `ps -aux | grep apache`
>
> //查看进程运行状态、查看内存使用情况的指令均可使用top指令 `top`



### 1.2 Linux里如何查看带有关键字的日志文件

- cat路劲/文件名 | grep 关键字

  ```shell
  # 返回test.log中包含http的所有行
  cat test.log | grep "http"
  ```

- grep -i 关键字 路径/文件名

  ```shell
  # 返回test.log中包含http的所有行(-i忽略大小写）
  grep -i "http" ./test.log
  ```



### 1.3 grep命令

grep命令。强大的文本搜素命令，grep（Global Regular Expression Print）**全局正则表达式搜索**

grep 的工作方式是这样的，它在一个或多个文件中搜索字符串模板。如果模板**包括空格，则必须被引用**，**模板后的所有字符串**被看作文件名。搜索的结果被送到标准输出，**不影响原文件内容**。

###### 解析：

> ```shell
> 1. //参数   
> 2. -A n --after-context显示匹配字符后n行   
> 3. -B n --before-context显示匹配字符前n行   
> 4. -C n --context 显示匹配字符前后n行   
> 5. -c --count 计算符合样式的列数   
> 6. -i 忽略大小写   
> 7. -l 只列出文件内容符合指定的样式的文件名称   
> 8. -f 从文件中读取关键词   
> 9. -n 显示匹配内容的所在文件中行数   
> 10. -R 递归查找文件夹   
> 11.    
> 12. //grep 的规则表达式:   
> 13. ^       #锚定行的开始 如：'^grep'匹配所有以grep开头的行。    
> 14. $       #锚定行的结束 如：'grep$'匹配所有以grep结尾的行。    
> 15. .       #匹配一个非换行符的字符 如：'gr.p'匹配gr后接一个任意字符，然后是p。     16. *       #匹配零个或多个先前字符 如：'*grep'匹配所有一个或多个空格后紧跟grep的行。   
> 17. .*      #一起用代表任意字符。     
> 18. []      #匹配一个指定范围内的字符，如'[Gg]rep'匹配Grep和grep。    
> 19. [^]     #匹配一个不在指定范围内的字符，如：'[^A-FH-Z]rep'匹配不包含A-R和T-Z的一个字母开头，紧跟rep的行。     
> 20. \(..\)  #标记匹配字符，如'\(love\)'，love被标记为1。      
> 21. \<      #锚定单词的开始，如:'\<grep'匹配包含以grep开头的单词的行。   
> 22. \>      #锚定单词的结束，如'grep\>'匹配包含以grep结尾的单词的行。   
> 23. x\{m\}  #重复字符x，m次，如：'0\{5\}'匹配包含5个o的行。    
> 24. x\{m,\} #重复字符x,至少m次，如：'o\{5,\}'匹配至少有5个o的行。     
> 25. x\{m,n\}#重复字符x，至少m次，不多于n次，如：'o\{5,10\}'匹配5--10个o的行。     26. \w      #匹配文字和数字字符，也就是[A-Za-z0-9]，如：'G\w*p'匹配以G后跟零个或多个文字或数字字符，然后是p。     
> 27. \W      #\w的反置形式，匹配一个或多个非单词字符，如点号句号等。     
> 28. \b      #单词锁定符，如: '\bgrep\b'只匹配grep。    
> //实例： 
> 1. //查找指定进程   
> 2. ps -ef | grep svn   
> 3.    
> 4. //查找指定进程个数   
> 5. ps -ef | grep svn -c   
> 6.    
> 7. //从文件中读取关键词   
> 8. cat test1.txt | grep -f key.log   
> 9.    
> 10. //显示包含 ed 或者 at 字符的内容行   
> 11. grep -E 'ed|at' test.txt 
> ```



### 1.4 Linux修改主机名的命令

- 如果是零时更改主机名，可以使用hostname命令

  ```shell
  sudo hostname <new-hostname> 
  # 例如： sudo hostname myDebian
  ```

- 如果是永久修改主机名，可以使用hostnamectl命令

  ```shell
  sudo hostnamectl set-hostname myDebian
  ```



### 1.5 Linux开机自动执行命令如何实现

- 方法 #1 - 使用cron任务

  除了常用格式（分 / 时 / 日 / 月 / 周）外，cron 调度器还支持 @reboot 指令。这个指令后面的参数是脚本（启动时要执行的那个脚本）的绝对路径。

  然而，这种方法需要注意两点：

  a) cron 守护进程必须处于运行状态（通常情况下都会运行），同时

  b) 脚本或 crontab 文件必须包含需要的环境变量。

- 方法 #2 - 使用 /etc/rc.d/rc.local

这个方法对于 systemd-based 发行版 Linux 同样有效。不过，使用这个方法，需要授予 /etc/rc.d/rc.local 文件执行权限：

```shell
chmod +x /etc/rc.d/rc.local
```

然后在这个文件底部添加脚本。



# 数据结构与算法



# C语言



# JAVA





# 补充知识

### <span id="数据库索引原理">数据库索引原理</span>

#### 1 二叉树$\rightarrow$平衡二叉树$\rightarrow$B-树$\rightarrow$B+树

- 二叉树

  > + 每个节点最多两个子树
  >
  > + 左子树值小于父节点，右子树值大于父节点

  若将升序的数组插入树中，树会变成：

  ![image-20230717100348417](D:\miao\note\八股文\八股文\image-20230717100348417.png)

  这棵树退化成一个**线性链表**，查询效率更低

  因此为了保持平衡，出现了**平衡二叉树**

- 平衡二叉树

  > + 满足二叉树的特性
  >
  > + 左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一颗平衡二叉树
  > + 查找效率和**二分查找**相同

  树的高度为$h$，那么每层最多容纳的节点数量为$2^{(n-1)}$，整棵树最多容纳节点$2^0+2^1+2^3+...+2^{(h-1)}$

- B-树

  一颗m阶的B-Tree的特征：

  > + 每个结点最多有m个子节点
  > + 除了根节点和叶子节点外，每个节点最少有$\frac{m}{2}$（向上取整）个子节点
  > + 如果根节点不是叶子节点，那根节点至少包含两个子节点
  > + 所有叶子节点都位于同一层
  > + 每个节点都包含K个元素，$\frac{m}{2}\leq k < m$（这里$\frac{m}{2}$向下取整）
  > + $左节点值 \leq 元素值 \leq 右节点值$

  B-Tree的查询效率不比平衡二叉树

  但查询经过的**节点数少**得多，因此查询一条数据需要**更少次数的磁盘I/O**

  ---

  **数据库中B-Tree的数据结构：**

  普通B-Tree的节点中，元素是一个数字

  > 但数据库中B-Tree，元素部分分成了key-data的形式
  >
  > key是数据的主键，data是具体的数据
  >
  > 找一条数的时候，就沿着根结点往下找就ok了，效率是比较高的

  ![image-20230717103615880](D:\miao\note\八股文\八股文\image-20230717103615880.png)

- B+树

  B+树是在B-Tree上的一种优化，使其更适合实现外存储索引结构

  > + 所有**非叶子节点**只存储**关键字信息**
  >
  > + 所有**数据**都存在叶子节点中
  >
  > + 所有叶子节点中包含了**全部元素信息**
  >
  > + 所有叶子节点之间都有一个**链指针**

​		![image-20230717104942142](D:\miao\note\八股文\八股文\image-20230717104942142.png)

---

#### 2 B-Tree or B+Tree

> 1.B-Tree非叶子节点也可以保存具体数据，因此查找到某个关键字时就可以返回；而B+Tree所有的数据都在叶子节点，每次查找都要找叶子节点。因此相同高度的B-Tree和B+Tree，**B-Tree的查找效率跟高**

> 2.B+Tree的所有数据都在叶子节点，且结点之间有指针连接，在找大于或小于某个关键字时。B+Tree只需要**沿着链表遍历**即可。而B-Tree则需要遍历该**关键字结点的根结点**去搜索。

> 3.由于B-Tree的每个结点（一个结点可以理解为一个数据页）都存储主键+实际数据，B+Tree的非叶子结点只存储关键字信息，而每个页大小有限，所以**同一页能存储的B-Tree比B+Tree存储的更少**。因此在相同总量的数据下，**B-Tree的深度比B+Tree的深度大**，查询时的**磁盘I/O次数更多**，影响查询效率。



#### 3 红黑树

---



### <span id='预编译'>MySQL预编译</span>

发送一条SQL语句给MySQL服务器时，MySQL服务器每次都会对其进行校验、解析

多数情况下，我们一条SQL可能会反复执行，而SQL语句也只可能是参数不同，类似的每次校验、解析过于浪费性能，因此提出了SQL语句的预编译

**预编译就是将一些灵活的参数值以占位符的形式替代掉，将参数值抽取出来，把SQL语句进行模板化。**让MySQL服务器在执行相同的SQL时，不需要再校验、解析

优势：

- **一次编译，多次运行**

- **防止SQL注入**

